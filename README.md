# CS-1332x

## Description:

> This is an online data structure and algorithm course from edX which is offered by Georgia Institute of Technology. All of my implementation of the data structures and algorithm can be found in the Assignment folder and my certificates can be found in the certificate folder.

![Professional Certificate](CS1332/Certificates/Professional%20Certificate%20_%20edX%20Credentials%20Cs%201332.pdf)
## Syllabus:

> [Part 1](https://www.edx.org/course/data-structures-algorithms-i-arraylists-linkedlists-stacks-and-queues)<br>
> [Part 2](https://www.edx.org/course/data-structures-algorithms-ii-binary-trees-heaps-skiplists-and-hashmaps)<br>
> [Part 3](https://www.edx.org/course/data-structures-algorithms-iii-avl-and-2-4-trees-divide-and-conquer-algorithms)<br>
> [Part 4](https://www.edx.org/course/data-structures-algorithms-iv-pattern-matching-djikstras-mst-and-dynamic-programming-algorithms)<br>

## Course Overview:

### Module 1: ArrayLists and Recursion

> This module introduces the implementation of the abstract data structure, ArrayList, and a review of recursive concepts, as recursion is essential in traversing and manipulating data structures in the future course.

> Assignment 1: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-1)<br>

### Module 2: LinkedLists

> In this module, it introduces a different type of data structure, which is called a linked data structure. Rather than storing data in an array which requires contiguous memory, these linked data structures store data anywhere in memory, and connect the data by keeping references/pointers between the locations. This allows a more flexible approach to data storage to better accommodate the dynamic nature of linked data structures.

> Assignment 2: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-2)<br>

### Module 3: Stacks and Queues

> In this module, it introduces the Stack and the Queue. Lists required a large degree of flexibility in accessing, removing, and adding at any index in the list. In contrast, Stacks and Queues are more specialized for operations at the ends of the data (the front and back of a list).

> Assignment 3: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-3)<br>

### Module 4: BST(Binary Search Tree) Introduction

> This module introduces tree terminology and increases your familiarity and comfort with these concepts. Four different traversal methods are discussed, which are procedures that move through each data in the tree in a predefined order. These are fairly basic ideas, but unlike a List, a simple loop won't suffice to traverse all of the data.

> Assignment 4: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-4)<br>

### Module 5: BST(Binary Search Tree) Operations & SkipLists

> In this module, it introduces the motivation for BSTs and how they relate to the binary search algorithm. It presents efficient procedures for searching, adding, and removing in a BST. Similar to how binary search works, BSTs work by splitting the data into subtrees with about half of the data as the level above it, yielding O(log(n))  running times on average.

> Assignment 5: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-5)<br>

### Module 6: Heaps

> Heaps are a binary tree-type data structure that prioritize access to either the smallest or largest item in the data structure depending on the heap type. In a sense, heaps are a specialist data structure most commonly coupled with the Priority Queue ADT. Whereas, BSTs are a generalist data structure useful for a lot of different operations.

> Assignment 6: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-6)<br>

### Module 7: HashMaps

> In this module,it introduces the big idea of how to achieve this incredible efficiency, known as hashing. HashMaps are very useful for searching specific data in our data structure. This is helpful when checking for membership of data that are using the search data as a unique identifier for some other data (in which case the searched data is called a key, and the implemented ADT is the Map ADT), and with the Set ADT.

> Assignment 7: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-7)<br>

### Module 8: AVLs

> In this module, it covers a sub classification of BSTs called AVL Trees, which are self-balancing trees. The name of the tree itself comes from its creators Adelson-Velsky and Landis. AVLs formally define what a "balanced tree" is, and they impose the additional restriction that by the end of any operation, the tree must remain balanced. For us, we'll be looking at how this applies to the add and remove operations specifically, and how the pointer reinforcement technique helps us implement the needed mechanisms (known as rotations) in a clean and intuitive way.

> Assignment 8: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-8)<br>

### Module 9: (2, 4) Trees

> In this module, it introduces a non-binary tree type known as (2, 4) trees. These (2, 4) trees inherit a similar order property found in BSTs, but (2,4) trees have flexible nodes that allow for multiple data and multiple children per node. (2,4) trees have a more strict shape property, requiring that every leaf node resides at the same depth. Thus, making the depth of (2,4) trees logarithmic.

> Assignment 9: None

### Module 10: Iterative Sorts

> In this module, we cover the more simple, "naÃ¯ve" sorts that refer to these sorting algorithms as iterative sorts since they all inherently rely on making multiple iterations of the data, fixing unsorted pairs.

> Assignment 10: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-10)<br>

### Module 11: Divide & Conquer Sorts

> In this module, it performs sorting with improved time complexity, but the ideas will utilize the divide and conquer paradigm. This new paradigm will split and stratify the data into smaller groups. Doing so allows this approach to avoid looking over all of the data too many times. We will learn the inherent limitations of comparison based sorting, as well as an interesting sorting algorithm that applies to specific types of data like integers.

> Assignment 11: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-11)<br>

### Module 12: Pattern Matching Algorithms

> This module is devoted to pattern matching algorithms. These algorithms operate on a long string called the text string, and a shorter string called the pattern string. The overall goal is to find occurrences of the pattern in the text.

> Assignment 12: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-12)<br>

### Module 13: Introduction to Graph Algorithms

> In this graph module, we discuss depth-first search (DFS) and breadth-first search (BFS), which are template exhaustive search algorithms. Lastly, Dijkstra's shortest path algorithm is presented. Dijkstra's algorithm can be thought of as a generalization of BFS for weighted graphs.

> Assignment 13: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-13)<br>

### Module 14: Minimum Spanning Trees (MST)

> In this module, it continues the exploration of graph algorithms by considering minimum spanning trees (MSTs). An MST is a tree subgraph of undirected graphs that has minimum cost while connecting all vertices. You can think of this as being the fewest and shortest cables needed to connect all points of interest.

> Assignment 14: [here](https://github.com/Leon-CYL/CS-1332/tree/main/CS1332/Assignments/Assignment-14)<br>

### Module 15: Dynamic Programming

> In this module, it introduces a simple yet highly effective algorithmic design technique known as dynamic programming (DP). Dynamic programming is similar to the divide and conquer recursive paradigm where we break the problem into subproblems and then combine them in some clever way. However, when we have overlapping subproblems, recursion can introduce a lot of redundant work, so dynamic programming improves upon this by introducing memoization, the storing of solutions to subproblems.

> Assignment 15: None
